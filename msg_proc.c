/*
 * msg_proc.c: implementation of the remote procedure "printmessage"
 *
 * Source: ?Using rpcgen?, http://www.cisco.com/en/US/docs/ios/sw_upgrades/interlink/r2_0/rpc_pr/rprpcgen.html
 */

#include <stdio.h>
#include <string.h>
#include <rpc/rpc.h>	/* always needed */
#include "msg.h"	/* need this too: msg.h will be generated by rpcgen */


//error messages

char *open_file_error = "Unable to open file output.txt";
char *wrong_input = "Incorrect input";

char **the_response;


 char *openFile(){

 	char *buffer;
 	long length;
 	FILE *f;

	f = fopen("output.txt", "r");// opens output file 
	if (f)
	{
		fseek (f, 0, SEEK_END);
		length = ftell (f);
		fseek (f, 0, SEEK_SET);
		buffer = malloc (length);
		if (buffer)
		{
			fread (buffer, 1, length, f);
		}
		fclose (f);	
	}
	if(buffer){
		return buffer;
	}
	else{
		printf("Error reading file");
		return(NULL);
	}
}

int findWordInSentence(char text[], char query[]){
	if(strstr(text, query)!=NULL){
		return 1;
	}
	else{
		return 0;
	}
}


int findSentenceLocation(char *query){
	const char s[2] = ".\n";
	
	char *text = openFile();

	char *sentence;

	sentence = strtok(text, s);
	
	int i = 0;
	while(sentence != NULL){
		//printf("%s\n", sentence);
		
		if(findWordInSentence(sentence, query) == 1){
			return i;
			break;
		}
		i++;
		sentence = strtok(NULL, s);
	}

	return (-1);
}




/******************************************
		PROCEDURES
*******************************************/


/*
 * Remote verson of "printmessage"
 */

 int *printmessage_1_svc(char **msg, struct svc_req *rqstp)
 {
	static int result; /* must be static! */
 	FILE *f;

	f = fopen("output.txt", "a");// opens output file 
	if (f == NULL) 
	{
		result = 0;
		return (&result);
	}

	fprintf(f, "%s\n", *msg);//writes message
	fclose(f);

	result = 1;
	return (&result);
}




char **search_1_svc(char **msg, struct svc_req *rqstp){
	
	const char s[2] = ".\n";

	char *word = *msg;	
	
	char *text = openFile();

	char **sentence;

	*sentence = strtok(text, s);

	while(*sentence != NULL){
		if(findWordInSentence(*sentence, word) == 1){
			break;
		}
		*sentence = strtok(NULL, s);
	}
	return sentence;
}


char **find_1_svc(int *index, struct svc_req *rqstp){

	const char *s = ".\n";

	int g = *index;

	char *text = openFile();

	char *sentence;

	sentence = strdup(strtok(text, s));

	int i = 0;

	while(sentence != NULL){

		if(i == g){
			break;
		}

		i++;
		sentence = strdup(strtok(NULL, s));
	}
	free(text);
	char **f;
	*f = sentence;
	printf("%s\n", sentence);

	printf("%s\n", *f);
	return f;
}

int *count_1_svc(char **msg, struct svc_req *rqstp){
	char *substring;
	int occur = 0;
	printf("count was called \n");
	static int result; 
	FILE *f;
	
	char *text = openFile();
	//printf(*msg,"\n");
	//printf(text);
	substring = strstr(text, *msg);
	printf(substring);
	while (substring!=NULL){
		printf("here2 \n",substring);
		occur++;
		substring++;
		printf("here1 %d \n",occur);
		substring = strstr(substring, *msg);
	}
	
	//printf("%s ", occur);
	//printf("printed text \n");
	
	result = occur;
	return (&result);
}



char **remove_string_1_svc(char **msg, struct svc_req *rqstp){
	
	char **response;
	char *firstResponse;

	const char *delimiter_characters = ".";

	char *text;//[ BUFFER_SIZE];
	char *last_token;

	int counter = 0;
	int result;

	int line = findSentenceLocation(*msg);

	if(line==-1)
	{
		printf("couldn't\n");
		*the_response = strdup("couldn't find word");

		return the_response;
	}

	FILE *output_file = fopen( "new_output.txt","w+");
   
    text = openFile();
    

    if( text == NULL ){
    	return &open_file_error;

    }else{

    	last_token = strtok( text, delimiter_characters );

    	counter=0;


    	while(last_token != NULL){

    		if (counter!=line){
    			fputs(last_token,output_file);
    			counter++;
    			last_token = strtok( NULL, delimiter_characters );
    			if( (last_token != NULL)){ fputs(".",output_file); }
    		}
    		else{
    			counter++;
    			last_token = strtok( NULL, delimiter_characters );
    		}
    		
    	}


    	remove("output.txt");
    
    	rename("new_output.txt", "output.txt");

     
    	fclose(output_file);

    }
    *response = "removed sentence";
    return response;	
}





char **delete_1_svc(char **query, struct svc_req *rqstp){

	int counter = 0;

	const char *delimiter = " \n";
	char **response;
	char *currentToken;
	char *text = openFile();
	if(text == NULL){ return &open_file_error; }

	FILE *output_file = fopen( "new_output.txt","w+");
	
	currentToken = strtok(text, delimiter);
	while(currentToken != NULL){

		if(strcmp(currentToken, *query)!=0){
			fputs(currentToken, output_file);
			currentToken = strtok(NULL, delimiter);
			if(currentToken != NULL){ fputs(" ", output_file); }
		}
		else{
			counter++;
			currentToken = strtok(NULL, delimiter);
		}		
	}
	remove("output.txt");
	rename("new_output.txt", "output.txt");

	fclose(output_file);
	// char * gg = ("Removed %d '%s'", counter, query);

	*response = "deleted thing";
	printf("%s\n", *response);
	return response;
}
